---
  title: npm run serve 的旅途风景
  authors:
    name: qwer_abc
    title: 不学习是没有钱途的！
    url: https://juejin.cn/user/897675666396296
    image_url: https://p3-passport.byteacctimg.com/img/user-avatar/25e21462cc5ec6a3dbaf10570b604e5b~300x300.image
  tags: [npm, vue-cli-service]
---

## 输入 npm run ... 后做了什么？

`node_modules\@vue\cli-service`🤖

**npm run serve**，其中这个 serve 的内容就是`vue-cli-service serve`

`"serve": "vue-cli-service serve"`

### vue-cli-service.js

npm 的语义版本器

```js
const semver = require('semver');
```

vue-cli 的共享工具

```js
const { error,... } = require('@vue/cli-shared-utils')
```

```js
const semver = require('semver');
const { error } = require('@vue/cli-shared-utils');
const requiredVersion = require('../package.json').engines.node;

// 检测node版本是否符合vue-cli运行的需求。不符合则打印错误并退出。
if (!semver.satisfies(process.version, requiredVersion)) {
  error(
    `You are using Node ${process.version}, but vue-cli-service ` +
      `requires Node ${requiredVersion}.\nPlease upgrade your Node version.`
  );
  process.exit(1);
}
```

cli-service 的核心类

`node_modules\@vue\cli-service\lib\Service.js`

```js
const Service = require('../lib/Service');
// 新建一个service的实例。并传入当前项目根路径。process.cwd()的结果一般是当前项目根路径
const service = new Service(process.env.VUE_CLI_CONTEXT || process.cwd());
```

参数处理

`"vue-cli-service serve"`

解析参数选项 `require('minimist')`

```js
const rawArgv = process.argv.slice(2); // [ 'serve' ]📝
const args = require('minimist')(rawArgv, {
  boolean: [
    // build
    'modern',
    'report',
    'report-json',
    'watch',
    // serve
    'open',
    'copy',
    'https',
    // inspect
    'verbose',
  ],
});
/*📝
{
  _: [ 'serve' ],
  modern: false,
  report: false,
  'report-json': false,
  'inline-vue': false,
  watch: false,
  open: false,
  copy: false,
  https: false,
  verbose: false
}
 */
const command = args._[0]; // serve📝
console.log(
  process.argv
) // ['node.exe 程序绝对路径','vue-cli-service.js 绝对路径'，'serve']📝
`npm run serve https`; // ['node.exe程序绝对路径','vue-cli-service.js绝对路径'，'serve'，'httpa']📝
```

`service.run('serve',{...args},['serve','https',...])`

```js
// 将参数传入service这个实例并启动后续工作。如果我们运行的是npm run serve。则command = "serve"。
service.run(command, args, rawArgv).catch(err => {
  error(err);
  process.exit(1);
});
```

上面的代码最后调用 `node_modules\@vue\cli-service\lib\Service.js` 中的 `run` 来进行项目的构建 📝

### Service.js

```js
// fs是filesystem的缩写，该模块提供本地文件的读写能力📝
const fs = require('fs');
// path模块是Node.js官方提供的、用来处理路径的模块📝
const path = require('path');
// JavaScript 调试实用程序。适用于 Node.js 和 Web 浏览器📝
const debug = require('debug');
// 修饰输出控制台内容的文字样式📝
const chalk = require('chalk');
// 读取 package.json 文件📝
const readPkg = require('read-pkg');
// 合并 webpack 配置,通常会把开发、生产文件分开配置,再进行与共同配置文件合并📝
const merge = require('webpack-merge');
// 详情见下文📌
const Config = require('webpack-chain');
// 主要是连接 plugin 的注册和service实例📝
const PluginAPI = require('./PluginAPI');
// .env文件中的配置📝
const loadEnv = require('./util/loadEnv');
// defaultsDeep()方法递归地分配`默认属性`📝
const defaultsDeep = require('lodash.defaultsdeep');
// Vue 的共享工具
const { warn, error, isPlugin, loadModule } = require('@vue/cli-shared-utils');

const { defaults, validate } = require('./options');
```

```js
const Config = require('webpack-chain');
```

webpack 的核心配置的创建和修改基于一个有潜在难于处理的 JavaScript 对象。虽然这对于配置单个项目来说还是 OK 的，但当你尝试跨项目共享这些对象并使其进行后续的修改就会变的混乱不堪，因为您需要深入了解底层对象的结构以进行这些更改。

`webpack-chain` 尝试通过提供可链式或顺流式的 API 创建和修改 webpack 配置。API 的 Key 部分可以由用户指定的名称引用，这有助于 跨项目修改配置方式 的标准化。📝

### Service 类核心代码

```js
module.exports = class Service {
  constructor (context, { plugins, pkg, inlineOptions, useBuiltIn } = {}) {
    // 将实例化的对象存储到全局变量 process.VUE_CLI_SERVICE📝
    process.VUE_CLI_SERVICE = this
    this.initialized = false
    // 一般是当前项目根目录路径。
    this.context = context
    this.inlineOptions = inlineOptions
    // webpack相关收集。不是本文重点。所以未列出该方法实现
    this.webpackChainFns = []
    this.webpackRawConfigFns = []
    this.devServerConfigFns = []
    //存储的命令,调用 run 时会传进来📝
    this.commands = {}
    // Folder containing the target package.json for plugins
    this.pkgContext = context
    // 键值对存储的pakcage.json对象，不是本文重点。所以未列出该方法实现
    this.pkg = this.resolvePkg(pkg)
    // 这个方法下方需要重点阅读🧩
    this.plugins = this.resolvePlugins(plugins, useBuiltIn)

    // 结果为{build: production, serve: development, ... },大意是收集插件中的默认配置信息
    // 标注build命令主要用于生产环境。
    this.modes = this.plugins.reduce((modes, { apply: { defaultModes }}) => {
      return Object.assign(modes, defaultModes)
    }, {})
  }

  init (mode = process.env.VUE_CLI_MODE) {
      // 是否初始化📝
      if (this.initialized) {
      return
    }
    this.initialized = true
    this.mode = mode

    // 加载.env文件中的配置
    if (mode) {
      this.loadEnv(mode)
    }
    // load base .env
    this.loadEnv()

------------------------------------------------------------------------------------------------
    // 读取用户的配置信息.一般为vue.config.js
    const userOptions = this.loadUserOptions()
    // 读取项目的配置信息并与用户的配置合并(用户的优先级高📌)
    this.projectOptions = defaultsDeep(userOptions, defaults())

    debug('vue:project-config')(this.projectOptions)
------------------------------------------------------------------------------------------------
    // 注册插件🧩
    this.plugins.forEach(({ id, apply }) => {
      apply(new PluginAPI(id, this), this.projectOptions)
    })

    // wepback相关配置收集
    if (this.projectOptions.chainWebpack) {
      this.webpackChainFns.push(this.projectOptions.chainWebpack)
    }
    if (this.projectOptions.configureWebpack) {
      this.webpackRawConfigFns.push(this.projectOptions.configureWebpack)
    }
  }

-2022-05-03 未读
  resolvePlugins (inlinePlugins, useBuiltIn) {
    const idToPlugin = id => ({
      id: id.replace(/^.\//, 'built-in:'),
      apply: require(id)
    })

    let plugins


    // 主要是这里。map得到的每个插件都是一个{id, apply的形式}
    // 其中require(id)将直接import每个插件的默认导出。
    // 每个插件的导出api为
    // module.exports = (PluginAPIInstance,projectOptions) => {
    //    PluginAPIInstance.registerCommand('cmdName（例如npm run serve中的serve）', args => {
    //        // 根据命令行收到的参数，执行该插件的业务逻辑
    //    })
    //    //  业务逻辑需要的其他函数
    //}
    // 注意这里是先在构造函数中resolve了插件。然后再run->init->方法中将命令，通过这里的的apply方法，
    // 将插件对应的命令注册到了service实例。
    const builtInPlugins = [
      './commands/serve',
      './commands/build',
      './commands/inspect',
      './commands/help',
      // config plugins are order sensitive
      './config/base',
      './config/css',
      './config/dev',
      './config/prod',
      './config/app'
    ].map(idToPlugin)

    // inlinePlugins与非inline得处理。默认生成的项目直接运行时候，除了上述数组的插件['./commands/serve'...]外，还会有
    // ['@vue/cli-plugin-babel','@vue/cli-plugin-eslint','@vue/cli-service']。
    // 处理结果是两者的合并，细节省略。
    if (inlinePlugins) {
        //...
    } else {
        //...默认走这条路线
      plugins = builtInPlugins.concat(projectPlugins)
    }

    // Local plugins 处理package.json中引入插件的形式，具体代码省略。

    return plugins
  }

  async run (name, args = {}, rawArgv = []) {
    // mode是dev还是prod？
    const mode = args.mode || (name === 'build' && args.watch ? 'development' : this.modes[name])

    // 收集环境变量、插件、用户配置
    this.init(mode)

    args._ = args._ || []
    let command = this.commands[name]
    if (!command && name) {
      error(`command "${name}" does not exist.`)
      process.exit(1)
    }
    if (!command || args.help) {
      command = this.commands.help
    } else {
      args._.shift() // remove command itself
      rawArgv.shift()
    }
    // 执行命令。例如vue-cli-service serve 则，执行serve命令。
    const { fn } = command
    return fn(args, rawArgv)
  }

  // 收集vue.config.js中的用户配置。并以对象形式返回。
  loadUserOptions () {
    // 此处代码省略，可以简单理解为
    // require(vue.config.js)
    return resolved
  }
}
```

**service 实例化后 📌：**

![](https://raw.githubusercontent.com/Kiyan-a/For_picGo/img/202205032235623.png)

### core.js

1.core-js 它是 JavaScript 标准库的 polyfill（垫片/补丁）, 新功能的 es'api'转换为大部分现代浏览器都可以支持
运行的一个'api' 补丁包集合。让我们在不兼容某些新特性的浏览器上，使用该新特性。 2.因为官方库对他介绍的形容
2.1.它支持最新的 ECMAScript 标准
2.2.它支持 ECMAScript 标准库提案
2.3.它支持一些 WHATWG / W3C 标准（跨平台或者 ECMAScript 相关）
2.4.它最大限度的模块化：你能仅仅加载你想要使用的功能
2.5.它能够不污染全局命名空间
2.6.它和 babel 紧密集成：这能够优化 core-js 的导入
2.7.它是最普遍、最流行 的给 JavaScript 标准库打补丁的方式

![](https://raw.githubusercontent.com/Kiyan-a/For_picGo/img/202205032111820.png)
